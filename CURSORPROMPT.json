Perfect — since you chose #3: rewrite new, here’s a single, strict Cursor hard-rewrite prompt that builds a clean monorepo with:
	•	Web app (Next.js 16) under the dashboard shell
	•	All working features: Companies (+notes highlight→tags), Routes (create/assign/schedule/drag order/outcomes), RouteMap with true directions polyline, Apple client-side geocoding, ICS export + Add to Calendar, Chat tab (/api/chat), Bulk JSON import UI, Sentry (tunneled)
	•	MCP server (editor tools against your APIs)
	•	DB package (Prisma schema + indexes + seed)
	•	iOS: drop-in Swift files to paste into your Xcode project:
Users/kylemillard/desktop_nocloud/dev/rb-copilot/rb-last-leg/LastLeg.xcodeproj

Copy-paste everything below into Cursor and run. Do not break it up. Do not deviate.

⸻

Title: DAYSWeeper — MONOREPO REWRITE (Web + DB + MCP + iOS) — DO NOT DEVIATE

You are a senior engineer. Create a fresh monorepo and migrate working code into it with all features wired and shippable.
Do NOT change frameworks or auth choices.
All pages must inherit the dashboard shell (sidebar/topbar).
Every button must reach a working endpoint; no stubs.

0) Monorepo scaffold (pnpm workspaces)

# repo root
mkdir -p daysweeper && cd daysweeper
printf '{ "name":"daysweeper","private":true,"packageManager":"pnpm@10","workspaces":["apps/*","packages/*"] }\n' > package.json
pnpm init -y

Add .gitignore:

node_modules
.next
dist
.env*
pnpm-*-allow-scripts.json

1) Packages: DB (Prisma) + shared config

mkdir -p packages/db/prisma packages/config
pnpm add -w prisma @prisma/client zod

packages/db/package.json

{ "name":"@daysweeper/db","version":"0.1.0","type":"module","main":"index.ts","dependencies":{"@prisma/client":"^7.3.0"},"devDependencies":{"prisma":"^7.3.0"},"scripts":{"generate":"prisma generate","migrate":"prisma migrate dev","deploy":"prisma migrate deploy"} }

packages/db/prisma/schema.prisma

generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

enum AccountState { ACCOUNT NEW_UNCONTACTED NEW_CONTACTED_NO_ANSWER }
enum StopOutcome { VISITED NO_ANSWER WRONG_ADDRESS FOLLOW_UP }
enum SupplyTier { OEM TIER_1 TIER_2 TIER_3 LOGISTICS_3PL TOOLING_CAPITAL_EQUIPMENT AFTERMARKET_SERVICES }

model Target {
  id             String   @id @default(cuid())
  company        String
  website        String?
  phone          String?
  email          String?
  addressRaw     String
  latitude       Decimal?
  longitude      Decimal?
  accountState   AccountState  @default(NEW_UNCONTACTED)
  supplyTier     SupplyTier?
  supplyGroup    String?
  supplySubtype  String?

  notes          TargetNote[]
  routeStops     RouteStop[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // rollups mirrored from RouteStop outcomes
  lastOutcome       StopOutcome?
  lastVisitedAt     DateTime?
  visitedCount      Int @default(0)
  noAnswerCount     Int @default(0)
  wrongAddressCount Int @default(0)
  followUpCount     Int @default(0)

  @@index([company])
  @@index([accountState])
  @@index([supplyTier])
  @@index([supplyGroup, supplySubtype])
}

model TargetNote {
  id        String   @id @default(cuid())
  targetId  String
  target    Target   @relation(fields: [targetId], references: [id], onDelete: Cascade)
  content   String
  tags      String[]
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([targetId])
  @@index([userId])
}

model Route {
  id               String     @id @default(cuid())
  name             String
  assignedToUserId String?
  scheduledFor     DateTime?
  stops            RouteStop[]
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  @@index([assignedToUserId])
}

model RouteStop {
  id        String      @id @default(cuid())
  routeId   String
  route     Route       @relation(fields: [routeId], references: [id], onDelete: Cascade)
  targetId  String
  target    Target      @relation(fields: [targetId], references: [id], onDelete: Cascade)
  seq       Int
  outcome   StopOutcome?
  visitedAt DateTime?
  note      String?
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  @@unique([routeId, seq])
  @@index([targetId])
}

packages/db/index.ts

import { PrismaClient } from "@prisma/client";
const globalForPrisma = global as unknown as { prisma?: PrismaClient };
export const prisma = globalForPrisma.prisma ?? new PrismaClient({ log: ["error"] });
if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

packages/db/prisma/seed.ts (optional)

import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
async function main(){
  if (await prisma.target.count()) return;
  await prisma.target.createMany({ data:[
    { company:"APR Containers - Louisville", addressRaw:"Louisville, KY" },
    { company:"River City Plastics", addressRaw:"Clarksville, IN" }
  ]});
}
main().finally(()=>prisma.$disconnect());

2) App: Web (Next.js 16)

pnpm dlx create-next-app@latest apps/web --ts --eslint --src-dir --app --import-alias @/*
cd apps/web
pnpm add @daysweeper/db @tanstack/react-query @tanstack/react-table dayjs use-debounce mapbox-gl @types/mapbox-gl ics @sentry/nextjs openai
pnpm add -D tailwindcss postcss autoprefixer

apps/web/tailwind.config.ts / postcss.config.js / globals.css → initialize Tailwind (keep starter defaults).

apps/web/next.config.ts

import { withSentryConfig } from "@sentry/nextjs";
const nextConfig: import("next").NextConfig = { experimental: { clientTraceMetadata: true } };
export default withSentryConfig(nextConfig, { silent: true }, { hideSourceMaps: true });

apps/web/instrumentation.ts

import * as Sentry from "@sentry/nextjs";
export async function register(){
  if (process.env.NEXT_RUNTIME === "nodejs") await import("./sentry.server.config");
  if (process.env.NEXT_RUNTIME === "edge")   await import("./sentry.edge.config");
}
export const onRequestError = Sentry.captureRequestError;

apps/web/sentry.client.config.ts

import * as Sentry from "@sentry/nextjs";
Sentry.init({ dsn: process.env.NEXT_PUBLIC_SENTRY_DSN, tunnel:"/api/monitoring", tracesSampleRate:0.2 });

apps/web/sentry.server.config.ts

import * as Sentry from "@sentry/nextjs";
Sentry.init({ dsn: process.env.NEXT_PUBLIC_SENTRY_DSN, tracesSampleRate:0.2 });

apps/web/sentry.edge.config.ts

import * as Sentry from "@sentry/nextjs";
Sentry.init({ dsn: process.env.NEXT_PUBLIC_SENTRY_DSN, tunnel:"/api/monitoring", tracesSampleRate:0.2 });

apps/web/app/api/monitoring/route.ts (Sentry tunnel)

export const runtime = "edge";
export async function POST(req: Request){
  const dsn = process.env.NEXT_PUBLIC_SENTRY_DSN!;
  const u = new URL(dsn); const proj = u.pathname.replace("/","");
  const ingest = `https://${u.host}/api/${proj}/envelope/`;
  const body = await req.text();
  const r = await fetch(ingest, { method:"POST", headers:{ "Content-Type":"application/x-sentry-envelope" }, body });
  return new Response(null, { status: r.status });
}

apps/web/app/layout.tsx

import "./globals.css";
import Providers from "./providers";
export default function RootLayout({ children }:{ children:React.ReactNode }){
  return <html lang="en"><body><Providers>{children}</Providers></body></html>;
}

apps/web/app/providers.tsx

"use client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
const qc = new QueryClient({ defaultOptions:{ queries:{ retry:1, refetchOnWindowFocus:false, staleTime:30000 } }});
export default function Providers({ children }:{children:React.ReactNode}){ return <QueryClientProvider client={qc}>{children}</QueryClientProvider>; }

2.1 Web APIs (use shared Prisma client)

Create these in apps/web/app/api and import from @daysweeper/db.
	•	Targets: targets/route.ts, targets/[id]/route.ts, targets/[id]/notes/route.ts
	•	Routes: routes/route.ts, routes/[id]/route.ts, routes/[id]/stops/route.ts, routes/stops/[stopId]/route.ts
	•	Analytics: analytics/overview/route.ts
	•	Scrape: scrape/company/route.ts (Cheerio)
	•	MapKit token: mapkit/token/route.ts (jose)
	•	Chat: chat/route.ts (OpenAI)
	•	Import: import/targets/route.ts
	•	ICS: routes/[id]/ical/route.ts

Use the exact implementations I sent earlier in this thread (they’re already complete and consistent) but import prisma from @daysweeper/db.

Example (apps/web/app/api/targets/route.ts):

import { NextResponse } from "next/server";
import { prisma } from "@daysweeper/db";
export async function GET(req:Request){
  const u = new URL(req.url); const q = u.searchParams.get("q") ?? undefined;
  const state = u.searchParams.get("state") ?? undefined;
  const tier = u.searchParams.get("tier") ?? undefined;
  const group = u.searchParams.get("group") ?? undefined;
  const subtype = u.searchParams.get("subtype") ?? undefined;
  const where:any = {};
  if(q) where.company = { contains:q, mode:"insensitive" };
  if(state) where.accountState = state;
  if(tier) where.supplyTier = tier;
  if(group) where.supplyGroup = group;
  if(subtype) where.supplySubtype = subtype;
  const rows = await prisma.target.findMany({ where, orderBy:{ createdAt:"desc" }, take:200 });
  return NextResponse.json(rows);
}
export async function POST(req:Request){
  try{
    const b = await req.json();
    const data = {
      company:String(b.company??"").trim(),
      addressRaw:String(b.addressRaw??""),
      website:b.website??null, phone:b.phone??null, email:b.email??null,
      accountState:b.accountState??"NEW_UNCONTACTED",
      supplyTier:b.supplyTier??null, supplyGroup:b.supplyGroup??null, supplySubtype:b.supplySubtype??null,
    };
    if(!data.company) return NextResponse.json({error:"company is required"},{status:400});
    const created = await prisma.target.create({ data }); return NextResponse.json(created,{status:201});
  }catch(e:any){ return NextResponse.json({error:e?.message??"Create failed"},{status:500}); }
}

(Repeat for the other API routes using the earlier code you already applied — no surprises.)

2.2 Web UI (dashboard shell)

Use a single base: /dashboard (or (dashboard) group if your starter uses that). Create pages:

apps/web/app/dashboard/overview/page.tsx
apps/web/app/dashboard/companies/page.tsx
apps/web/app/dashboard/companies/[id]/page.tsx
apps/web/app/dashboard/routes/page.tsx
apps/web/app/dashboard/routes/[id]/page.tsx
apps/web/app/dashboard/scrape/page.tsx
apps/web/app/dashboard/chat/page.tsx
apps/web/app/dashboard/import/page.tsx

	•	Companies list: search + filters + Quick Add + table (TanStack Table)
	•	Company profile: overview (inline account state), taxonomy selects, NotesPanel (highlight→tag, from earlier)
	•	Routes list: create/delete; shows Assigned + Date + #stops
	•	Route builder: Assign & Schedule buttons, Available companies (left), Sortable stops (right), Save Order, Outcome buttons, RouteMap (Mapbox) with true directions polyline and Geocode Missing (Apple) button
	•	Scrape: URL paste → draft + candidates → Create or Link & Merge
	•	Chat: simple chat box; optional fields for targetId/routeId context
	•	Import: textarea to POST JSON array → shows result
	•	Overview: wired to analytics endpoint

RouteMap with true directions polyline (Mapbox Directions)
Add helper: src/components/routes/RouteMap.tsx extending the previous map to call the Directions API when ≥2 points exist:

// inside effect after pts computed
if (pts.length >= 2) {
  const coords = pts.map(p => p.coord.join(",")).join(";");
  const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coords}?overview=full&geometries=geojson&access_token=${process.env.NEXT_PUBLIC_MAPBOX_TOKEN}`;
  fetch(url).then(r=>r.json()).then(j=>{
    const line = j.routes?.[0]?.geometry;
    if (!line) return;
    if (map.getSource("route-line"))
      (map.getSource("route-line") as mapboxgl.GeoJSONSource).setData({ type:"Feature", geometry: line, properties:{} } as any);
    else {
      map.addSource("route-line", { type:"geojson", data:{ type:"Feature", geometry: line, properties:{} } as any });
      map.addLayer({ id:"route-line-layer", type:"line", source:"route-line", paint:{ "line-color":"#2563eb","line-width":4 }});
    }
  }).catch(()=>{ /* fallback to straight line if desired */ });
}

Apple client geocoding
Add src/lib/mapkit-loader.ts + src/lib/apple-geocode.ts (from the previous patch) and Geocode Missing (Apple) button in the builder header (already specified).

Deep links in StopRow: open Apple/Google Maps if lat/lon exists.

ICS: add “Download .ics”, “Add to Google”, “Add to Outlook” buttons (from earlier).

Sentry: tunnel points to /api/monitoring. Confirm DSN env set.

3) App: MCP server

mkdir -p apps/mcp
printf '{ "name":"@daysweeper/mcp","version":"0.1.0","type":"module","dependencies":{"@modelcontextprotocol/sdk":"^0.2.0","node-fetch":"^3.3.2"},"scripts":{"start":"node index.js"} }\n' > apps/mcp/package.json

apps/mcp/index.js

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import fetch from "node-fetch";

const API = process.env.API_BASE || "http://localhost:3000";
const KEY = process.env.INTERNAL_API_KEY || "";

async function api(path) {
  const r = await fetch(`${API}${path}`, { headers: { "x-api-key": KEY } });
  if (!r.ok) throw new Error(`API ${path} ${r.status}`);
  return r.json();
}

const server = new Server({ name:"daysweeper-mcp", version:"0.1.0" });

server.tool({
  name:"list_companies",
  description:"List companies with optional search",
  inputSchema:{ type:"object", properties:{ q:{ type:"string" } } },
  async *call({ q }) { return { items: await api(`/api/targets${q?`?q=${encodeURIComponent(q)}`:""}`) }; }
});

server.tool({
  name:"get_route",
  description:"Get route details by id",
  inputSchema:{ type:"object", properties:{ id:{ type:"string" } }, required:["id"] },
  async *call({ id }) { return await api(`/api/routes/${id}`); }
});

server.start();

Editor config (Cursor) .cursor/mcp.json:

{
  "mcpServers": {
    "daysweeper": {
      "command": "node",
      "args": ["apps/mcp/index.js"],
      "env": {
        "API_BASE": "http://localhost:3000",
        "INTERNAL_API_KEY": "dev_only_long_random_string"
      }
    }
  }
}

(Optional: also keep Sentry MCP config as earlier if you like.)
